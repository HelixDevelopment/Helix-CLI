package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"dev.helix.code/internal/config"
	"dev.helix.code/internal/hardware"
	"dev.helix.code/internal/llm"
)

// CLI represents the command-line interface
type CLI struct {
	config         *config.Config
	modelManager   *llm.ModelManager
	hardwareDetector *hardware.Detector
}

// NewCLI creates a new CLI instance
func NewCLI(cfg *config.Config) *CLI {
	return &CLI{
		config:         cfg,
		modelManager:   llm.NewModelManager(),
		hardwareDetector: hardware.NewDetector(),
	}
}

// Initialize sets up the CLI environment
func (c *CLI) Initialize() error {
	log.Println("üöÄ Initializing Helix CLI...")

	// Detect hardware
	hardwareInfo, err := c.hardwareDetector.Detect()
	if err != nil {
		log.Printf("Warning: Hardware detection failed: %v", err)
	} else {
		log.Printf("‚úÖ Hardware detected: %s CPU, %s GPU, %s RAM", 
			hardwareInfo.CPU.Model, hardwareInfo.GPU.Model, hardwareInfo.Memory.TotalRAM)
		log.Printf("üìä Optimal model size: %s", c.hardwareDetector.GetOptimalModelSize())
	}

	// Initialize LLM providers
	if err := c.initializeProviders(); err != nil {
		return fmt.Errorf("failed to initialize providers: %w", err)
	}

	// Check provider health
	c.checkProviderHealth()

	log.Println("‚úÖ Helix CLI initialized successfully")
	return nil
}

// Run executes the CLI with the given arguments
func (c *CLI) Run(args []string) error {
	if len(args) < 2 {
		return c.showHelp()
	}

	command := args[1]
	switch command {
	case "help", "--help", "-h":
		return c.showHelp()
	case "version", "--version", "-v":
		return c.showVersion()
	case "models":
		return c.listModels()
	case "hardware":
		return c.showHardwareInfo()
	case "health":
		return c.checkHealth()
	case "chat":
		return c.startChat(args[2:])
	case "generate":
		return c.generateCode(args[2:])
	case "plan":
		return c.planProject(args[2:])
	case "test":
		return c.runTests(args[2:])
	case "debug":
		return c.debugCode(args[2:])
	case "refactor":
		return c.refactorCode(args[2:])
	default:
		return fmt.Errorf("unknown command: %s. Use 'help' for available commands", command)
	}
}

// initializeProviders sets up all LLM providers
func (c *CLI) initializeProviders() error {
	// Initialize Llama.cpp provider if configured
	if c.config.LLM.LlamaCPP.Enabled {
		llamaConfig := llm.LlamaConfig{
			ModelPath:     c.config.LLM.LlamaCPP.ModelPath,
			ContextSize:   c.config.LLM.LlamaCPP.ContextSize,
			GPUEnabled:    c.config.LLM.LlamaCPP.GPUEnabled,
			GPULayers:     c.config.LLM.LlamaCPP.GPULayers,
			ServerHost:    c.config.LLM.LlamaCPP.ServerHost,
			ServerPort:    c.config.LLM.LlamaCPP.ServerPort,
			ServerTimeout: time.Duration(c.config.LLM.LlamaCPP.ServerTimeout) * time.Second,
		}

		provider, err := llm.NewLlamaCPPProvider(llamaConfig)
		if err != nil {
			log.Printf("Warning: Failed to initialize Llama.cpp provider: %v", err)
		} else {
			if err := c.modelManager.RegisterProvider(provider); err != nil {
				log.Printf("Warning: Failed to register Llama.cpp provider: %v", err)
			}
		}
	}

	// Initialize Ollama provider if configured
	if c.config.LLM.Ollama.Enabled {
		ollamaConfig := llm.OllamaConfig{
			BaseURL:      c.config.LLM.Ollama.BaseURL,
			DefaultModel: c.config.LLM.Ollama.DefaultModel,
			Timeout:      time.Duration(c.config.LLM.Ollama.Timeout) * time.Second,
			KeepAlive:    time.Duration(c.config.LLM.Ollama.KeepAlive) * time.Second,
			StreamEnabled: c.config.LLM.Ollama.StreamEnabled,
		}

		provider, err := llm.NewOllamaProvider(ollamaConfig)
		if err != nil {
			log.Printf("Warning: Failed to initialize Ollama provider: %v", err)
		} else {
			if err := c.modelManager.RegisterProvider(provider); err != nil {
				log.Printf("Warning: Failed to register Ollama provider: %v", err)
			}
		}
	}

	// Initialize OpenAI provider if configured
	if c.config.LLM.OpenAI.Enabled {
		// OpenAI provider would be initialized here
		log.Println("‚ö†Ô∏è OpenAI provider configuration not yet implemented")
	}

	return nil
}

// checkProviderHealth checks the health of all providers
func (c *CLI) checkProviderHealth() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	health := c.modelManager.HealthCheck(ctx)
	for providerType, status := range health {
		log.Printf("üè• %s: %s (latency: %v, models: %d)", 
			providerType, status.Status, status.Latency, status.ModelCount)
	}
}

// Command implementations

func (c *CLI) showHelp() error {
	helpText := `
Helix CLI - AI-Powered Development Assistant

Usage:
  helix <command> [arguments]

Commands:
  help                    Show this help message
  version                 Show version information
  models                  List available AI models
  hardware                Show hardware information
  health                  Check system health
  chat <prompt>           Start interactive chat
  generate <description>  Generate code from description
  plan <project>          Create project plan
  test <code>             Generate and run tests
  debug <issue>           Debug code issues
  refactor <code>         Refactor existing code

Examples:
  helix chat "How do I implement a REST API in Go?"
  helix generate "a function to sort a list of integers"
  helix plan "web application with user authentication"
  helix test "my_function in file.py"
  helix debug "memory leak in C++ application"
  helix refactor "legacy JavaScript code to use modern patterns"

For more information, visit: https://helix.dev
`
	fmt.Println(helpText)
	return nil
}

func (c *CLI) showVersion() error {
	fmt.Println("Helix CLI v1.0.0")
	fmt.Println("Build: development")
	fmt.Println("Go version: go1.24.0")
	return nil
}

func (c *CLI) listModels() error {
	models := c.modelManager.GetAvailableModels()
	if len(models) == 0 {
		fmt.Println("No models available. Check your provider configurations.")
		return nil
	}

	fmt.Println("\nAvailable AI Models:")
	fmt.Println("===================")
	for _, model := range models {
		fmt.Printf("\nüì¶ %s\n", model.Name)
		fmt.Printf("   Provider: %s\n", model.Provider)
		fmt.Printf("   Context: %d tokens\n", model.ContextSize)
		fmt.Printf("   Capabilities: %v\n", model.Capabilities)
		if model.Description != "" {
			fmt.Printf("   Description: %s\n", model.Description)
		}
	}

	fmt.Printf("\nTotal: %d models available\n", len(models))
	return nil
}

func (c *CLI) showHardwareInfo() error {
	hardwareInfo, err := c.hardwareDetector.Detect()
	if err != nil {
		return fmt.Errorf("failed to detect hardware: %w", err)
	}

	fmt.Println("\nHardware Information:")
	fmt.Println("====================")
	fmt.Printf("CPU: %s (%s)\n", hardwareInfo.CPU.Model, hardwareInfo.CPU.Architecture)
	fmt.Printf("Cores: %d\n", hardwareInfo.CPU.Cores)
	fmt.Printf("GPU: %s (%s)\n", hardwareInfo.GPU.Model, hardwareInfo.GPU.Vendor)
	if hardwareInfo.GPU.VRAM != "" {
		fmt.Printf("VRAM: %s\n", hardwareInfo.GPU.VRAM)
	}
	fmt.Printf("RAM: %s\n", hardwareInfo.Memory.TotalRAM)
	fmt.Printf("Platform: %s/%s\n", hardwareInfo.Platform.OS, hardwareInfo.Platform.Architecture)
	
	optimalSize := c.hardwareDetector.GetOptimalModelSize()
	fmt.Printf("\nüí° Recommended model size: %s\n", optimalSize)
	
	flags := c.hardwareDetector.GetCompilationFlags()
	if len(flags) > 0 {
		fmt.Printf("üîß Compilation flags: %v\n", flags)
	}

	return nil
}

func (c *CLI) checkHealth() error {
	fmt.Println("\nSystem Health Check:")
	fmt.Println("===================")

	// Check hardware
	hardwareInfo, err := c.hardwareDetector.Detect()
	if err != nil {
		fmt.Printf("‚ùå Hardware detection: FAILED (%v)\n", err)
	} else {
		fmt.Printf("‚úÖ Hardware detection: OK (%s CPU, %s GPU)\n", 
			hardwareInfo.CPU.Model, hardwareInfo.GPU.Model)
	}

	// Check providers
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	health := c.modelManager.HealthCheck(ctx)
	if len(health) == 0 {
		fmt.Println("‚ùå No LLM providers available")
	} else {
		for providerType, status := range health {
			if status.Status == "healthy" {
				fmt.Printf("‚úÖ %s: HEALTHY (latency: %v)\n", providerType, status.Latency)
			} else {
				fmt.Printf("‚ùå %s: %s\n", providerType, status.Status)
			}
		}
	}

	// Check models
	models := c.modelManager.GetAvailableModels()
	if len(models) == 0 {
		fmt.Println("‚ùå No AI models available")
	} else {
		fmt.Printf("‚úÖ Models: %d available\n", len(models))
	}

	return nil
}

// Placeholder implementations for AI commands

func (c *CLI) startChat(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("chat command requires a prompt")
	}

	prompt := args[0]
	fmt.Printf("üí¨ Chatting about: %s\n\n", prompt)
	
	// TODO: Implement actual chat functionality
	fmt.Println("ü§ñ Chat functionality coming soon...")
	fmt.Println("For now, you can use the 'generate' command for code generation.")
	
	return nil
}

func (c *CLI) generateCode(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("generate command requires a description")
	}

	description := args[0]
	fmt.Printf("üõ†Ô∏è  Generating code for: %s\n\n", description)
	
	// TODO: Implement actual code generation
	fmt.Println("üöß Code generation functionality coming soon...")
	fmt.Println("This will use the optimal AI model to generate code based on your description.")
	
	return nil
}

func (c *CLI) planProject(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("plan command requires a project description")
	}

	project := args[0]
	fmt.Printf("üìã Planning project: %s\n\n", project)
	
	// TODO: Implement actual project planning
	fmt.Println("üìä Project planning functionality coming soon...")
	fmt.Println("This will create a detailed project plan with tasks and timelines.")
	
	return nil
}

func (c *CLI) runTests(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("test command requires code or file to test")
	}

	target := args[0]
	fmt.Printf("üß™ Testing: %s\n\n", target)
	
	// TODO: Implement actual test generation and execution
	fmt.Println("üî¨ Test generation and execution coming soon...")
	fmt.Println("This will generate and run comprehensive tests for your code.")
	
	return nil
}

func (c *CLI) debugCode(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("debug command requires an issue description")
	}

	issue := args[0]
	fmt.Printf("üêõ Debugging issue: %s\n\n", issue)
	
	// TODO: Implement actual debugging
	fmt.Println("üîç Debugging functionality coming soon...")
	fmt.Println("This will analyze and help fix issues in your code.")
	
	return nil
}

func (c *CLI) refactorCode(args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("refactor command requires code to refactor")
	}

	code := args[0]
	fmt.Printf("üîß Refactoring: %s\n\n", code)
	
	// TODO: Implement actual refactoring
	fmt.Println("üîÑ Code refactoring functionality coming soon...")
	fmt.Println("This will improve your code structure and maintainability.")
	
	return nil
}

// Main function
func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Create CLI instance
	cli := NewCLI(cfg)

	// Initialize CLI
	if err := cli.Initialize(); err != nil {
		log.Fatalf("Failed to initialize CLI: %v", err)
	}

	// Handle interrupt signals
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	
	go func() {
		<-sigCh
		log.Println("\nüõë Received interrupt signal, shutting down...")
		cancel()
	}()

	// Run CLI with command-line arguments
	if err := cli.Run(os.Args); err != nil {
		log.Fatalf("Error: %v", err)
	}
}